
range :: Int -> Int -> Int -> Array Int
range n m step = []

type Coord = {
    row :: Int,
    col :: Int
}

coords :: Int -> Int -> Coord
coords cols i = { row: i / cols, col: i `mod` cols }

dCoords :: Int -> Int -> Int -> Coord
dCoords cols x y = {
    row: (p.row - q.row),
    col: (p.col - q.col)
} where
    p = coords cols x
    q = coords cols y

pathBetween :: Int -> Int -> Int -> Maybe (Array Int)
pathBetween columns u v =
    if drow == 0 then
        Just (if u < v then range (u + 1) v 1 else range (u - 1) (v - 1) (-1))
    else if dcol == 0 then
        Just (if u < v then range (u + columns) v columns else range (u - columns) (v - columns) (-columns))
    else
        Nothing
    where {row: drow, col: dcol} = dCoords columns u v


type State2 = {
    position :: Array Int,
    rotation :: Int
}

aligned :: State2 -> Array Boolean
aligned { position, rotation } = 
    position # mapWithIndex (\index color -> color == (index + rotation) `mod` (position # length))

data Mode = Mode1 | Mode2 | Mode3 | Mode4

type State3 = {
    position :: Array Int,
    mode :: Mode,
    columns :: Int
}

neighbor :: State3 -> Int -> Int -> Boolean
neighbor {columns, mode} index1 index2 = 
    case mode of
        Mode1 -> n1
        Mode2 -> n1
        Mode3 -> same
        Mode4 -> hv 
    where
    {row: dx, col: dy} = dCoords columns index1 index2
    same = index1 == index2
    n1 = dx * dx + dy * dy == 1
    hv = dx * dy == 0

