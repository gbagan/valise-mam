module Game.Queens.View where

import MyPrelude
import Lib.Util (map3)
import Data.Array.NonEmpty (toArray, head) as N
import Pha (VDom, Prop, h, text)
import Pha.Action ((üîç))
import Pha.Html (div', br, class', attr, svg, key, style, width, height, href, click, pointerenter, pointerleave)
import Game.Core (_position, _nbRows, _nbColumns, _help, _pointer)
import Game.Queens.Model (State, Piece(..), _selectedPiece, _selectedSquare, _allowedPieces, _multiPieces,
                           piecesList, capturableSquares, attackedBySelected,
                           playA, selectSquareA, selectPieceA, selectAllowedPieceA, toggleMultiPiecesA)
import UI.Template (template, card, incDecGrid, gridStyle, trackPointer, cursorStyle)
import UI.Icon (Icon(..))
import UI.Icons (iconbutton, icongroup, iconSizesGroup, iconSelectGroupM, ihelp, irules, ireset)

tooltip :: Piece -> String
tooltip Queen = "Reine"
tooltip King = "Roi"
tooltip Rook = "Tour"
tooltip Bishop = "Fou"
tooltip Knight = "Cavalier"
tooltip _ = "Pi√®ce personnalis√©e"

square :: forall a. { piece :: Piece, capturable :: Boolean, selected :: Boolean, nonavailable :: Boolean} -> Array (Prop a) -> VDom a
square { piece, capturable, selected, nonavailable} props =
    div' ([
        class' "queens-square" true,
        class' "queens-square-capturable" capturable,
        class' "queens-square-nonavailable" nonavailable,
        class' "queens-square-selected" selected
    ] <> props) $ if piece == Empty then [] else [
        svg [width "100%", height "100%", class' "queen-piece" true] [
            h "use" [href $ "#piece-" <> show piece, attr "x" "10%", attr "y" "10%",
                     width "80%", height "80%", class' "queens-piece" true] []
        ]
    ]

view :: forall a. Lens' a State -> State -> VDom a
view lens state = template lens {config, board, rules, winTitle} state where
    position = state^._position
    rows = state^._nbRows
    columns = state^._nbColumns
        
    config = card "Les reines" [
        iconSizesGroup lens state [Tuple 4 4, Tuple 5 5, Tuple 7 7, Tuple 8 8] true,
        iconSelectGroupM lens state "Pi√®ces disponibles" piecesList (state^._allowedPieces) selectAllowedPieceA \piece opt ->
            opt{icon = IconSymbol $ "#piece-" <> show piece, tooltip = Just $ tooltip piece},
        icongroup "Options" $ [
            iconbutton state (_{icon = IconSymbol "#customize",
                              selected = N.head (state^._allowedPieces) == Custom,
                              tooltip = Just "Cr√©e ta propre propre pi√®ce"}) [],
            iconbutton state (_{icon = IconSymbol "#piece-mix", selected = state^._multiPieces, tooltip = Just "Mode mixte"}) [
                click $ lens üîç toggleMultiPiecesA
            ]
        ] <> ([ihelp, ireset, irules] <#> \x -> x lens state)
    ]
            {-    
            I.Group({ title: `Meilleur score (${state.bestScore || 0})` },
                I.BestScore()

    -}
    pieceSelector = div' [class' "ui-flex-center gutter2 queens-pieceselector" true] $
        N.toArray (state^._allowedPieces) <#> \piece ->
            let name = show piece in
            iconbutton state (\x -> x{
                    selected = piece == state^._selectedPiece,
                    icon = IconSymbol $ "#piece-" <> name
                }) [
                    key $ name,
                    click $ lens üîç selectPieceA piece
                ]
        

    cursor pp = div' ([class' "ui-cursor" true] <> cursorStyle pp rows columns 80.0) [
        svg [width "100%", height "100%"] [
            h "use" [href $ "#piece-" <> show (state^._selectedPiece)] []
        ]
    ]

    grid = div' ([class' "ui-board" true] <> gridStyle rows columns 5 <> trackPointer lens) $   
        (map3 position (attackedBySelected state) (capturableSquares state) \index piece attacked capturable ->
            square {piece,
                selected: attacked || state^._selectedSquare == Just index,
                nonavailable: state^._help && (piece /= Empty || capturable),
                capturable
            } [
                style "width" $ show (100.0 / toNumber columns) <> "%",
                style "height" $ show (100.0 / toNumber rows) <> "%",
                click $ lens üîç playA index,
                pointerenter $ lens üîç selectSquareA (Just index),
                pointerleave $ lens üîç selectSquareA Nothing
            ]
        ) <> (state^._pointer # maybe [] (pure ‚àò cursor))

    board = div' [] [
        pieceSelector,
        incDecGrid lens state [grid]
    ]

    directions = [1, 2, 3, 0, 0, 4, 7, 6, 5]

    {-
    const CustomPieceDialog = () =>
        Dialog({
            onOk: [actions.showDialog, null],
            title: 'Pi√®ce personnalis√©e'
        },
            div({class: 'flex'},
                div({class: 'queens-custompiece-grid'},
                    div({
                        class: 'queens-grid',
                        style: gridStyle(state.rows, state.columns)
                    },
                        state.customMoves.local.map((selected, index) =>
                            Square({
                                style: { width: '20%', height: '20%' },
                                key: index,
                                piece: index === 12 && 'custom',
                                selected,
                                onclick: index !== 12 && [actions.flipLocal, index],
                            })
                        )
                    )
                ),
                div ({class: 'flex queens-custompiece-directions'},
                    state.customMoves.directions.map((selected, i) =>
                        Icon({
                            key: i,
                            selected,
                            symbol: i != 4 ? 'arrow' : null,
                            style: {transform: `rotate(${45 * directions[i]}deg)`},
                            onclick: i != 4 && [actions.flipDirection, i]
                        })
                    )
                )
            )
        );

    const BestScoreDialog = () =>
        Dialog({
            title: 'Meilleur score',
            onOk: [actions.showDialog, null]
        },
            div({ class: 'ui-flex-center queens-bestscore-container' },
                div({
                    class: 'queens-grid',
                    style: gridStyle(state.rows, state.columns)
                },
                    state.bestPosition.map(piece =>
                        Square({
                            style: {
                                width: 100 / state.columns + '%',
                                height: 100 / state.rows + '%'
                            },
                            piece,
                        })
                    )
                )
            )
        );


    const dialogs = {
        bestscore: BestScoreDialog,
        custompiece: CustomPieceDialog,
    };
    -}
    rules = [
        text "Place le plus de pi√®ces possible sur ta grille sans qu\'aucune ne soit menac√©e par une autre pi√®ce.", br,
        text "Tu peux choisir de jouer avec diff√©rentes pi√®ces comme celles du jeu d\'√©checs."
    ]
    {-
            Fabrique ta propre pi√®ce avec <Icon image="customize" />. Cette pi√®ce est repr√©sent√©e par <Icon image="piece-custom" /><br />
            Le mode mixte permet de jouer avec plusieurs pi√®ces.<br />
            Pour activer ce mode, clique sur <Icon image="piece-mix" /><br />
            Plusieurs tailles de tableau te sont propos√©es.<br />
            L√† encore, tu peux personnaliser la taille du plateau avec <Icon text="NxM" /><br />
            Au cours de la partie, il peut √™tre difficile de voir les cases libres (non menac√©es par des pi√®ces pos√©es).<br />
            Tu peux alors voir les cases libres avec l&#39;aide: <Icon image="help" />
    -}

    winTitle = ""