module Game.Jetons.Model where

import Prelude
import Data.Tuple (Tuple (Tuple))
import Data.Maybe (fromMaybe)
import Data.Traversable (sequence)
import Data.Array ((!!), filter, sortWith, modifyAtIndices, all, replicate)
import Optic.Core (lens, Lens', set, (^.))
import Lib.Core (repeat2)
import Lib.Random (randomInt)
import Lib.Game (class Game, State, canPlay, _position, _turn)

data Move = Move Int Int
data ExtState = Ext {
    nbPiles :: Int,
    length :: Int
}

type NimState = State (Array (Tuple Int Int)) ExtState

instance nimGame :: Game (Array (Tuple Int Int)) ExtState Move where
    canPlay state (Move pile pos) = fromMaybe false $ do
        Tuple p1 p2 <- state^._position !! pile
        pure $ pos /= p1 && pos /= p2 && if state^._turn == 0 then pos < p2 else pos > p1

    play state (Move pile pos) = state^._position # modifyAtIndices [pile]
        \(Tuple p1 p2) -> if state^._turn == 0 then Tuple pos p2 else Tuple p1 pos
    
    isLevelFinished state = state^._position # all
        \(Tuple p1 p2) -> p2 - p1 == 1 && (if state^._turn == 1 then p2 == state^._length - 2 else p1 == 0)

    initialPosition state = 
        sequence $ replicate (state~._nbPiles) $ do
            x <- randomInt 5
            y <- randomInt 5
            pure $ Tuple x (y + 5)

possibleMoves :: NimState -> Array Move
possibleMoves state@(St {nbPiles, position, length, turn}) =
    repeat2 nbPiles length (\{row, col} -> Move row col)
    # filter (\m -> canPlay state m)
    # sortWith \(Move pile pos) -> fromMaybe 0 $ do
        Tuple a b <- position !! pile
        pure $ if turn == 0 then a - pos else pos - b

-- isLostPosition (St {position}) = position
--    # map \t -> snd t - snd t - 1
--    # foldl


--    state: {
--        nbPiles: 4,
--        mode: 'expert',  // random | expert | duel
--        turn: 0,   //  0: player 1,  1: player 2
--        length: 10,
--    },

--    actions: $ => ({
--        setNbPiles: $.newGame('nbPiles'),
--        setLimit: $.newGame('limit'),
--        shuffle: $.newGame(),
--    }),

--    computed: state => ({
--        isLevelFinished: isLevelFinished(state),
--    })
--});
